#+title: Journal 2024
#+author: Olivier leroy


* <2024-01-01 Mon>

Nouvelle annee, resolution tenir le journal jusqu'au bout et transformer certains partie en memo (blog post?)

- ne pas distinguer le journal du taff du perso
- pas encore certains d'utiliser org roam + un journal a voir

** org mod :org:mode:

    Utiliser plus souvent les tags ref: https://orgmode.org/guide/Tags.html

** building repro analytical pipeline :rstats:

*** chapitre 4:

Pedagogique, sans doute tres utile pour un etudiant et/ou un jeune DA

Chose nouvelle apprise: ~git stash~

Permet de revenir as ~HEAD~

#+begin_src bash
mkdir temp/
cd temp
git init
echo "bob" > unfichier.txt
git add .
git commit -m "init"
rm unfichier.txt
git add .
git stash
cd ..
rm -rf temp
#+end_src

#+RESULTS:
| Reinitialized | existing | Git       | repository | in    | /Users/olivierleroy/Documents/oli/prise_de_notes/temp/.git/ |     |    |         |         |      |
| On            | branch   | master    |            |       |                                                           |     |    |         |         |      |
| nothing       | to       | commit,   | working    | tree  | clean                                                     |     |    |         |         |      |
| Saved         | working  | directory | and        | index | state                                                     | WIP | on | master: | 5c5c45b | init |

*trunk base development* :  https://trunkbaseddevelopment.com/

On vera sans doute plus tard mais en gros on dev sur dev et fork des releases qui elles sont stables.

* <2024-01-02 Tue>

** chapitre 5 reproducible pip R :rstats:

trunk based dev: en gros des commits tres frequents, faciliter par de la double revision. L'objectif est de diviser le development en petite taches permettant de petite commit, dev sur une autre branche et merger rapidement.

Dans le cas de taches importantes il est recommande d'utiliser une technique appelle "branch bt abstraction" qui consiste a utiliser des placeholders qui seront ameliore petit a petit. (https://martinfowler.com/bliki/BranchByAbstraction.html)

Le tronc est sense etre toujours "production rdy"

l'obligation de sousmettre une PR pourmodifier le tronc renforce cette pratique

*** BEAD :mbtiles:PG:

pas d option de filter sur un array dans mbtiles

bcp de wrangling pour former un jeux de donnees test, pas mal de changement de specs,

les fonctions d'aggregation de PG peuvent prendre un order by et un distinct:

~json_agg('isp_id' || ' ' || isp_id order by isp_id) as isp_num~

** TED

vue metadata avec Dolley

* <2024-01-03 Wed>

** bead :PG:

~ctid~ est une colonne utile pour avoir un id pour des jointures, elle reference la place en memoire de l info

https://www.postgresql.org/docs/current/ddl-system-columns.html

*** RDOF

targets a un format url pour suivre l update d'un fichier en ligne cf ~format = "url"~

https://www.fcc.gov/document/fcc-proposes-over-8m-fines-against-22-rdof-applicants-defaults

** general

penser a organiser un meeting ou on fixe les donnees, leur types, leur noms

* <2024-01-04 Thu>

** bead

0 for null in isp_id for every count

pas mal de test avec le types pour les mbtiles fixe la structure de donnees

*** pg stuff :PG:

replace() a un equivalent  REGEXP_replace(isp_idv2, '{|}', '', 'g')  avec un argument pour faire une regex global

todo demain clean le mess d acs pipeline


** jour poses

01/01/2024
05/27/2024
06/14/2024
06/19/2024
09/01/2024
11/28/2024
11/29/2024
12/25/2024

** chapitre 6 Functional programming

Utilisation de fonction d'ordre superieur

on a un premier passage qui indique ce qu'est l'etat a travers un exemple de ce qui est en memoire. L'etat ne devrait pas changer le resultats d'une fonction.

Certains fonctions peuvent incrementer ou changer un etat dans le programe. c'est le cas par exemple d'une boucle. Je suis pas fan de l'argument de deinir la list dans comme argument.

Si une fonction est pure elle doit ne prendre en compte que des arguments dans ses arguments et pas dans d'autre environement.

#+begin_src R
y <- 10
bad <- function(x) {
       x + y
}
# un mauvais example
#+end_src


Dans R les fonction peuvent aussi etre des arguments

#+begin_src R
g <- function(number, f, ...) {
  f(number, ...)
    }
#+end_src

ici l'ellipsis permet de passer des argument pris en compte par f, l'exmple typique est ~na.rm = TRUE~.

Programmer avec cela en tete indique qu'il est sage de mettre des gardes fou a ses functions, l'exemple utilise est ~sqrt(-5)~ qui ne produit que un warnings et ne retourne pas un nombre mais NaN.

 Un autre exmemple que l'auteur utilise est un wrapper generique autour de ~trycatch()~ qui permet de faire une fonction qui retourne un warnings en erreur.

 Cela permet aussi d'introduire les function factories: ie des fonctions qui vont retourner des fonctions.

 Les arguments par defaut sont rapdiement introduits.

 Assertive/safe programming est aussi introduit. Ce n'est pas toujours limpide pour moi jusqu'ou tester.

 l'aurteur deconseil aussi d'utiliser des fonctions recursives. Aucune idee de pkoi mon intuition est que R est pas fait pour garder en memoire (ici dans l env de la fonction) le resultat de la fonction precedente.

 L'auteur se reclame aussi de la penser unix pour demander une decomposition en petite fonction. Je suis pas expert.

 IL y a un gros passage sur l'interet des listes. Cela lui permet d'introduire Reduce et Map. Il y aussi un gros passage sur les lists dans les colonnes et comment cela permet de faire des graphiques parametres.

 S3, purrr et withr sont introduit succintement.

* <2024-01-05 Fri>

jour de nettoyage, bead et TED pipeline

bcp a faire sur BEAD, car c'est un mixe de sql lance via pg admin et de targets

je ne suis pas claire sur ce que fait crew, est une interface derriere plusieurs moteur ou un moteur sur une interface specifique

* <2024-01-07 Sun>

** R stuff :rstats:

~getS3method("function", "class")~ permet de lister les methodes

~sf:::print.sgbp~  marche aussi

* <2024-01-08 Mon>

** TED

pas mal de pb avec la pipeine, merged le bazard et reussi a mettre a jour, pas vraiment appris grand chose si ce n'est que data table n'est multi thread que si ~libomp~ est disponible.

** BEAD

pas mal d'explo avec isp la version json introduit des ~"~ ce qui change l'ordre du classement mais ne devrais pas changer le nombre ..

* <2024-01-09 Tue>


flood

** bead

essaie de regrouper en une seule pileine BEAD stuff

** <2024-01-10 Wed>

pas de meetng et discussion sur l'archivage, l'utilisation du cache

nettoyage de certains repos et merge de branche

un peu de test d sqlite avec gpkg
